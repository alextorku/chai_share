# Copyright 2016    Duc Le  University of Michigan
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections import OrderedDict
import sys
import os
import re

import chaipy.common as common
import chaipy.io as io
import numpy

def parse_per_utt(fname):
    """
    :type fname: str
    :param fname: Kaldi per-utt eval results file (generated by score.sh)
    
    Return a dict of utt-level records.
    """
    results = OrderedDict()
    with open(fname, 'r') as f:
        for line in f:
            ary = line.strip().split()
            common.CHK_GT(len(ary), 2)
            if ary[0] not in results:
                results[ary[0]] = {}
            if ary[1] == '#csid':
                results[ary[0]][ary[1]] = [int(x) for x in ary[2:]]
            else:
                results[ary[0]][ary[1]] = ary[2:]
    return results
    
def ali_with_length_read(ali_fname, ordered=True, expand=False):
    """
    Read a Kaldi alignment with length file. Returns a dictionary.
        If `expand` is False, each value is a list of 2-element tuples
        containing the token ID and length in frames.
        If `expand` is True, each value is an expanded list of labels.
    """
    ret = OrderedDict() if ordered else {}
    with open(ali_fname, 'r') as f:
        for line in f:
            ary = line.strip().replace(';', '').split()
            common.CHK_EQ(len(ary) % 2, 1)
            if ary[0] in ret:
                log('WARNING: duplicate key {}'.format(ary[0]))
            ret[ary[0]] = []
            for i in range(1, len(ary), 2):
                if expand:
                    ret[ary[0]].extend([ary[i]] * int(ary[i+1]))
                else:
                    ret[ary[0]].append((ary[i], int(ary[i+1])))
    return ret
    
def ivector_ark_read(ark_fname, ordered=True, dtype=numpy.float32):
    """ Read a textual ark containing i-vectors. Returns a dictionary. """
    ret = OrderedDict() if ordered else {}
    with open(ark_fname, 'r') as f:
        prefix = ''
        for line in f.readlines():
            line = line.strip()
            if line.endswith(']'):
                line = '{} {}'.format(prefix, line)
                ary = line.replace('[', '').replace(']', '').split()
                ret[ary[0]] = numpy.asarray(ary[1:], dtype=dtype)
                prefix = ''
            elif line.endswith('['):
                prefix = line
            else:
                raise ValueError('Invalid line: {}'.format(line))
    return ret
    
def word_ali_read(fname, ordered=True):
    """ Read a word-level alignment file (generated by phone2word_ali.py).
    Returns a map with utt name as key, each maps to a list of `ExtendedTimeTag`.

    If ordered=True, keys will be sorted in the order that they are inserted.
    """
    alis = OrderedDict() if ordered else {}
    utt = None
    with open(fname, 'r') as f:
        for line in f.readlines():
            line = line.strip()
            if line.startswith('"'):
                utt = line.replace('"', '')
                if utt not in alis:
                    alis[utt] = []
            elif line != '.':
                ary = line.split()
                phone_tag = common.TimeTag(
                    ary[2], int(ary[0]), int(ary[1]), float(ary[3])
                )
                if len(ary) == 5:
                    alis[utt].append(common.ExtendedTimeTag(ary[4]))
                alis[utt][-1].add_tag(phone_tag)
    return alis

def print_matrix(name, matrix, stream=sys.stdout):
    """ Print content of matrix in Kaldi format.
    :type name: str
    :param name: Matrix name
    
    :type matrix: Numpy array or list of lists
    :param matrix: Matrix content
    """
    print >> stream, '{}  ['.format(name)
    for i in range(len(matrix)):
        vec_str = ' '.join([str(x) for x in matrix[i]])
        suffix = '' if i < len(matrix) - 1 else ' ]'
        print >> stream, '  {}{}'.format(vec_str, suffix)

def print_vector(name, vector, stream=sys.stdout):
    """ Print content of vector in Kaldi format.
    :type name: str
    :param name: Vector name
    
    :type vector: Numpy array or list
    :param vector: Vector content
    """
    vec_str = ' '.join([str(x) for x in vector])
    print >> stream, '{} [ {} ]'.format(name, vec_str)
